mcast: build pim reg interface to master

The per-vrf register tunnel should be bound to the vrf master
interface for consistency and identification of the vrf relationshsip
in interface netlink messages.

Signed-off-by: Patrick Ruddy <pruddy@vyatta.att-mail.com>
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -56,6 +56,7 @@
 #include <linux/compat.h>
 #include <linux/export.h>
 #include <linux/rhashtable.h>
+#include <linux/rtnetlink.h>
 #include <net/ip_tunnels.h>
 #include <net/checksum.h>
 #include <net/netlink.h>
@@ -561,10 +562,12 @@ static void reg_vif_setup(struct net_dev
 	dev->features		|= NETIF_F_NETNS_LOCAL;
 }
 
-static struct net_device *ipmr_reg_vif(struct net *net, struct mr_table *mrt)
+static struct net_device *ipmr_reg_vif(struct net *net, struct mr_table *mrt,
+				       int master)
 {
 	struct net_device *dev;
 	char name[IFNAMSIZ];
+	int err;
 
 	if (mrt->id == RT_TABLE_DEFAULT)
 		sprintf(name, "pimreg");
@@ -588,6 +591,11 @@ static struct net_device *ipmr_reg_vif(s
 	if (dev_open(dev, NULL))
 		goto failure;
 
+	if (master) {
+		err = do_set_master(dev, master, NULL);
+		if (err != 0)
+			goto failure;
+	}
 	dev_hold(dev);
 
 	return dev;
@@ -829,7 +837,7 @@ static void ipmr_update_thresholds(struc
 }
 
 static int vif_add(struct net *net, struct mr_table *mrt,
-		   struct vifctl *vifc, int mrtsock)
+		   struct vifctl *vifc, int mrtsock, int master)
 {
 	struct netdev_phys_item_id ppid = { };
 	int vifi = vifc->vifc_vifi;
@@ -851,7 +859,7 @@ static int vif_add(struct net *net, stru
 		 */
 		if (mrt->mroute_reg_vif_num >= 0)
 			return -EADDRINUSE;
-		dev = ipmr_reg_vif(net, mrt);
+		dev = ipmr_reg_vif(net, mrt, master);
 		if (!dev)
 			return -ENOBUFS;
 		err = dev_set_allmulti(dev, 1);
@@ -1452,7 +1460,8 @@ int ip_mroute_setsockopt(struct sock *sk
 		}
 		if (optname == MRT_ADD_VIF) {
 			ret = vif_add(net, mrt, &vif,
-				      sk == rtnl_dereference(mrt->mroute_sk));
+				      sk == rtnl_dereference(mrt->mroute_sk),
+				      sk->sk_bound_dev_if);
 		} else {
 			ret = vif_delete(mrt, vif.vifc_vifi, 0, NULL);
 		}
--- a/include/linux/rtnetlink.h
+++ b/include/linux/rtnetlink.h
@@ -27,6 +27,8 @@ struct sk_buff *rtmsg_ifinfo_build_skb(i
 				       int new_ifindex);
 void rtmsg_ifinfo_send(struct sk_buff *skb, struct net_device *dev,
 		       gfp_t flags);
+int do_set_master(struct net_device *dev, int ifindex,
+		  struct netlink_ext_ack *extack);
 
 
 /* RTNL is used as a global lock for all changes to network configuration  */
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -2379,7 +2379,7 @@ static int do_setvfinfo(struct net_devic
 	return err;
 }
 
-static int do_set_master(struct net_device *dev, int ifindex,
+int do_set_master(struct net_device *dev, int ifindex,
 			 struct netlink_ext_ack *extack)
 {
 	struct net_device *upper_dev = netdev_master_upper_dev_get(dev);
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -47,6 +47,7 @@
 #include <net/ip6_checksum.h>
 #include <linux/netconf.h>
 #include <net/ip_tunnels.h>
+#include <linux/rtnetlink.h>
 
 #include <linux/nospec.h>
 
@@ -636,10 +637,12 @@ static void reg_vif_setup(struct net_dev
 	dev->features		|= NETIF_F_NETNS_LOCAL;
 }
 
-static struct net_device *ip6mr_reg_vif(struct net *net, struct mr_table *mrt)
+static struct net_device *ip6mr_reg_vif(struct net *net, struct mr_table *mrt,
+					int master)
 {
 	struct net_device *dev;
 	char name[IFNAMSIZ];
+	int err;
 
 	if (mrt->id == RT6_TABLE_DFLT)
 		sprintf(name, "pim6reg");
@@ -660,6 +663,12 @@ static struct net_device *ip6mr_reg_vif(
 	if (dev_open(dev, NULL))
 		goto failure;
 
+	if (master) {
+		err = do_set_master(dev, master, NULL);
+		if (err != 0)
+			goto failure;
+	}
+
 	dev_hold(dev);
 	return dev;
 
@@ -854,7 +863,7 @@ static void ip6mr_update_thresholds(stru
 }
 
 static int mif6_add(struct net *net, struct mr_table *mrt,
-		    struct mif6ctl *vifc, int mrtsock)
+		    struct mif6ctl *vifc, int mrtsock, int master)
 {
 	int vifi = vifc->mif6c_mifi;
 	struct vif_device *v = &mrt->vif_table[vifi];
@@ -875,7 +884,7 @@ static int mif6_add(struct net *net, str
 		 */
 		if (mrt->mroute_reg_vif_num >= 0)
 			return -EADDRINUSE;
-		dev = ip6mr_reg_vif(net, mrt);
+		dev = ip6mr_reg_vif(net, mrt, master);
 		if (!dev)
 			return -ENOBUFS;
 		err = dev_set_allmulti(dev, 1);
@@ -1666,7 +1675,8 @@ int ip6_mroute_setsockopt(struct sock *s
 			return -ENFILE;
 		rtnl_lock();
 		ret = mif6_add(net, mrt, &vif,
-			       sk == rtnl_dereference(mrt->mroute_sk));
+			       sk == rtnl_dereference(mrt->mroute_sk),
+			       sk->sk_bound_dev_if);
 		rtnl_unlock();
 		return ret;
 
