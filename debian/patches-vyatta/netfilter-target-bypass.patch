netfilter: add a new BYPASS target

Add a new BYPASS target to netfilter that will send packets to
a user specified interface so that they can be processed by a
userspace dataplane process instead of the kernel.

Signed-off-by: Paul Atkins <patkins@vyatta.att-mail.com>
---
 net/netfilter/Kconfig     |    9 ++
 net/netfilter/Makefile    |    1 
 net/netfilter/xt_BYPASS.c |  159 ++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 169 insertions(+)

--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -765,6 +765,15 @@ config NETFILTER_XT_TARGET_AUDIT
 
 	  To compileit as a module, choose M here. If unsure, say N.
 
+config NETFILTER_XT_TARGET_BYPASS
+       tristate '"BYPASS" target support'
+       depends on IP_NF_MANGLE
+       help
+         This options adds a `BYPASS' target, which allows to specify
+         an interface to forward the packet to.
+
+         To compile it as a module, choose M here.  If unsure, say N.
+
 config NETFILTER_XT_TARGET_CHECKSUM
 	tristate "CHECKSUM target support"
 	depends on IP_NF_MANGLE || IP6_NF_MANGLE
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -135,6 +135,7 @@ obj-$(CONFIG_NETFILTER_XT_NAT) += xt_nat
 
 # targets
 obj-$(CONFIG_NETFILTER_XT_TARGET_AUDIT) += xt_AUDIT.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_BYPASS) += xt_BYPASS.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_CHECKSUM) += xt_CHECKSUM.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_CLASSIFY) += xt_CLASSIFY.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_CONNSECMARK) += xt_CONNSECMARK.o
--- /dev/null
+++ b/net/netfilter/xt_BYPASS.c
@@ -0,0 +1,173 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  Copyright (c) 2019, AT&T Intellectual Property.  All rights reserved.
+ *  Copyright (C) 2011-2015 Brocade Communications Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * "BYPASS" target extension for Xtables
+ */
+#include <linux/module.h>
+#include <linux/netfilter.h>
+#include <linux/skbuff.h>
+#include <linux/notifier.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/inet.h>
+#include <net/route.h>
+#include <net/ip6_route.h>
+#include <uapi/linux/netfilter/xt_BYPASS.h>
+
+struct xt_bypass_priv {
+	struct notifier_block notifier;
+	struct xt_bypass_tginfo	*tginfo;
+	int iif;
+	int oif;
+};
+
+static unsigned int
+bypass_tg(struct sk_buff *pskb, const struct xt_action_param *par)
+{
+	const struct xt_bypass_tginfo *info = par->targinfo;
+	struct net_device *iif_dev;
+
+	if (info->priv->oif == -1)
+		return NF_ACCEPT;
+
+	if (xt_family(par) != NFPROTO_IPV4 &&
+	    xt_family(par) != NFPROTO_IPV6)
+		return NF_ACCEPT;
+
+	pskb->dev = __dev_get_by_index(&init_net, info->priv->oif);
+	if (!pskb->dev)
+		return NF_DROP;
+
+	if (info->priv->iif != -1) {
+		iif_dev = __dev_get_by_index(&init_net, info->priv->iif);
+		if (iif_dev)
+			pskb->skb_iif = iif_dev->ifindex;
+	}
+
+	/* FIXME - pskb->protocol is already set to htons(ETH_P_IP[V6]).
+	 * this unnecessary byte swap is undone in dataplane
+	 */
+	pskb->protocol = (xt_family(par) == NFPROTO_IPV4) ? ETH_P_IP :
+		ETH_P_IPV6;
+
+	dev_queue_xmit(pskb);
+	return NF_STOLEN;
+}
+
+static int bypass_netdev_event(struct notifier_block *this, unsigned long event,
+			       void *ptr)
+{
+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+	struct xt_bypass_priv *priv;
+
+	priv = container_of(this, struct xt_bypass_priv, notifier);
+	switch (event) {
+	case NETDEV_REGISTER:
+		if (strcmp(dev->name, priv->tginfo->iif) == 0)
+			priv->iif = dev->ifindex;
+		else if (strcmp(dev->name, priv->tginfo->oif) == 0)
+			priv->oif = dev->ifindex;
+		break;
+	case NETDEV_UNREGISTER:
+		if (dev->ifindex == priv->iif)
+			priv->iif = -1;
+		else if (dev->ifindex == priv->oif)
+			priv->oif = -1;
+		break;
+	case NETDEV_CHANGENAME:
+		if (strcmp(dev->name, priv->tginfo->iif) == 0)
+			priv->iif = dev->ifindex;
+		else if (dev->ifindex == priv->iif)
+			priv->iif = -1;
+
+		if (strcmp(dev->name, priv->tginfo->oif) == 0)
+			priv->oif = dev->ifindex;
+		else if (dev->ifindex == priv->oif)
+			priv->oif = -1;
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int bypass_tg_check(const struct xt_tgchk_param *par)
+{
+	struct xt_bypass_tginfo *info = par->targinfo;
+	struct xt_bypass_priv *priv;
+
+	/* Must set oif, but iif is optional. */
+	if (info->oif[0]) {
+		if (strcmp(info->oif,  info->iif) == 0)
+			return -EINVAL;
+
+		priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+		if (!priv)
+			return -ENOMEM;
+
+		priv->tginfo  = info;
+		priv->iif     = -1;
+		priv->oif     = -1;
+		priv->notifier.notifier_call = bypass_netdev_event;
+		info->priv    = priv;
+
+		register_netdevice_notifier(&priv->notifier);
+	} else {
+		info->priv = NULL;
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void bypass_tg_destroy(const struct xt_tgdtor_param *par)
+{
+	struct xt_bypass_tginfo *info = par->targinfo;
+
+	if (info->priv) {
+		unregister_netdevice_notifier(&info->priv->notifier);
+		kfree(info->priv);
+	}
+}
+
+static struct xt_target bypass_tg_reg[] __read_mostly = {
+	{
+		.name     = "BYPASS",
+		.revision = 0,
+		.family   = NFPROTO_UNSPEC,
+		.target   = bypass_tg,
+		.targetsize = sizeof(struct xt_bypass_tginfo),
+		.checkentry = bypass_tg_check,
+		.destroy    = bypass_tg_destroy,
+		.me       = THIS_MODULE,
+	},
+};
+
+static int __init bypass_tg_init(void)
+{
+	return xt_register_targets(bypass_tg_reg, ARRAY_SIZE(bypass_tg_reg));
+}
+
+static void __exit bypass_tg_exit(void)
+{
+	xt_unregister_targets(bypass_tg_reg, ARRAY_SIZE(bypass_tg_reg));
+}
+
+module_init(bypass_tg_init);
+module_exit(bypass_tg_exit);
+MODULE_AUTHOR("Paul Atkins <patkins@vyatta.att-mail.com>");
+MODULE_DESCRIPTION("Xtables: Take packets and pass them to specified interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ipt_BYPASS");
+MODULE_ALIAS("ip6t_BYPASS");
