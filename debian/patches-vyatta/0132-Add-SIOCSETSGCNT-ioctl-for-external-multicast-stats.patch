---
 include/linux/mroute_base.h  |    2 +
 include/uapi/linux/mroute.h  |    1 
 include/uapi/linux/mroute6.h |    3 +-
 net/ipv4/ipmr.c              |   60 ++++++++++++++++++++++++++++++++++++++-----
 net/ipv6/ip6mr.c             |   53 +++++++++++++++++++++++++++++++++----
 5 files changed, 106 insertions(+), 13 deletions(-)

--- a/include/linux/mroute_base.h
+++ b/include/linux/mroute_base.h
@@ -8,6 +8,7 @@
 #include <net/sock.h>
 #include <net/fib_notifier.h>
 #include <net/ip_fib.h>
+#include <uapi/linux/rtnetlink.h>
 
 /**
  * struct vif_device - interface representor for multicast routing
@@ -146,6 +147,7 @@ struct mr_mfc {
 			unsigned long pkt;
 			unsigned long wrong_if;
 			unsigned long lastuse;
+			struct rta_mfc_stats dp_stat;
 			unsigned char ttls[MAXVIFS];
 			refcount_t refcount;
 		} res;
--- a/include/uapi/linux/mroute.h
+++ b/include/uapi/linux/mroute.h
@@ -34,6 +34,7 @@
 #define SIOCGETVIFCNT	SIOCPROTOPRIVATE	/* IP protocol privates */
 #define SIOCGETSGCNT	(SIOCPROTOPRIVATE+1)
 #define SIOCGETRPF	(SIOCPROTOPRIVATE+2)
+#define SIOCSETSGCNT	(SIOCPROTOPRIVATE+3)
 
 /* MRT_FLUSH optional flags */
 #define MRT_FLUSH_MFC	1	/* Flush multicast entries */
--- a/include/uapi/linux/mroute6.h
+++ b/include/uapi/linux/mroute6.h
@@ -36,7 +36,8 @@
 
 #define SIOCGETMIFCNT_IN6	SIOCPROTOPRIVATE	/* IP protocol privates */
 #define SIOCGETSGCNT_IN6	(SIOCPROTOPRIVATE+1)
-#define SIOCGETRPF	(SIOCPROTOPRIVATE+2)
+#define SIOCGETRPF		(SIOCPROTOPRIVATE+2)
+#define SIOCSETSGCNT_IN6	(SIOCPROTOPRIVATE+3)
 
 /* MRT6_FLUSH optional flags */
 #define MRT6_FLUSH_MFC	1	/* Flush multicast entries */
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -1618,6 +1618,8 @@ int ip_mroute_getsockopt(struct sock *sk
 /* The IP multicast ioctl support routines. */
 int ipmr_ioctl(struct sock *sk, int cmd, void __user *arg)
 {
+	bool found = false;
+	struct rhlist_head *tmp, *list;
 	struct sioc_sg_req sr;
 	struct sioc_vif_req vr;
 	struct vif_device *vif;
@@ -1651,6 +1653,24 @@ int ipmr_ioctl(struct sock *sk, int cmd,
 		}
 		read_unlock(&mrt_lock);
 		return -EADDRNOTAVAIL;
+	case SIOCSETSGCNT:
+		if (copy_from_user(&sr, arg, sizeof(sr)))
+			return -EFAULT;
+
+		rtnl_lock();
+
+		c = ipmr_cache_find(mrt, sr.src.s_addr, sr.grp.s_addr);
+		if (!c) {
+			rtnl_unlock();
+			return -EADDRNOTAVAIL;
+		}
+		write_lock_bh(&mrt_lock);
+		c->_c.mfc_un.res.dp_stat.mfcs_packets = sr.pktcnt;
+		c->_c.mfc_un.res.dp_stat.mfcs_bytes = sr.bytecnt;
+		c->_c.mfc_un.res.dp_stat.mfcs_wrong_if = sr.wrong_if;
+		write_unlock_bh(&mrt_lock);
+		rtnl_unlock();
+		return 0;
 	case SIOCGETSGCNT:
 		if (copy_from_user(&sr, arg, sizeof(sr)))
 			return -EFAULT;
@@ -1658,9 +1678,12 @@ int ipmr_ioctl(struct sock *sk, int cmd,
 		rcu_read_lock();
 		c = ipmr_cache_find(mrt, sr.src.s_addr, sr.grp.s_addr);
 		if (c) {
-			sr.pktcnt = c->_c.mfc_un.res.pkt;
-			sr.bytecnt = c->_c.mfc_un.res.bytes;
-			sr.wrong_if = c->_c.mfc_un.res.wrong_if;
+			sr.pktcnt = c->_c.mfc_un.res.pkt +
+					c->_c.mfc_un.res.dp_stat.mfcs_packets;
+			sr.bytecnt = c->_c.mfc_un.res.bytes +
+					c->_c.mfc_un.res.dp_stat.mfcs_bytes;
+			sr.wrong_if = c->_c.mfc_un.res.wrong_if +
+					c->_c.mfc_un.res.dp_stat.mfcs_wrong_if;
 			rcu_read_unlock();
 
 			if (copy_to_user(arg, &sr, sizeof(sr)))
@@ -1693,6 +1716,9 @@ struct compat_sioc_vif_req {
 
 int ipmr_compat_ioctl(struct sock *sk, unsigned int cmd, void __user *arg)
 {
+	bool found = false;
+	struct mfc_cache_cmp_arg cmp_arg;
+	struct rhlist_head *tmp, *list;
 	struct compat_sioc_sg_req sr;
 	struct compat_sioc_vif_req vr;
 	struct vif_device *vif;
@@ -1726,6 +1752,25 @@ int ipmr_compat_ioctl(struct sock *sk, u
 		}
 		read_unlock(&mrt_lock);
 		return -EADDRNOTAVAIL;
+
+	case SIOCSETSGCNT:
+		if (copy_from_user(&sr, arg, sizeof(sr)))
+			return -EFAULT;
+
+		rtnl_lock();
+
+		c = ipmr_cache_find(mrt, sr.src.s_addr, sr.grp.s_addr);
+		if (!c) {
+			rtnl_unlock();
+			return -EADDRNOTAVAIL;
+		}
+		write_lock_bh(&mrt_lock);
+		c->_c.mfc_un.res.dp_stat.mfcs_packets = sr.pktcnt;
+		c->_c.mfc_un.res.dp_stat.mfcs_bytes = sr.bytecnt;
+		c->_c.mfc_un.res.dp_stat.mfcs_wrong_if = sr.wrong_if;
+		write_unlock_bh(&mrt_lock);
+		rtnl_unlock();
+		return 0;
 	case SIOCGETSGCNT:
 		if (copy_from_user(&sr, arg, sizeof(sr)))
 			return -EFAULT;
@@ -1733,9 +1778,12 @@ int ipmr_compat_ioctl(struct sock *sk, u
 		rcu_read_lock();
 		c = ipmr_cache_find(mrt, sr.src.s_addr, sr.grp.s_addr);
 		if (c) {
-			sr.pktcnt = c->_c.mfc_un.res.pkt;
-			sr.bytecnt = c->_c.mfc_un.res.bytes;
-			sr.wrong_if = c->_c.mfc_un.res.wrong_if;
+			sr.pktcnt = c->_c.mfc_un.res.pkt +
+					c->_c.mfc_un.res.dp_stat.mfcs_packets;
+			sr.bytecnt = c->_c.mfc_un.res.bytes +
+					c->_c.mfc_un.res.dp_stat.mfcs_bytes;
+			sr.wrong_if = c->_c.mfc_un.res.wrong_if +
+					c->_c.mfc_un.res.dp_stat.mfcs_wrong_if;
 			rcu_read_unlock();
 
 			if (copy_to_user(arg, &sr, sizeof(sr)))
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -1891,6 +1891,23 @@ int ip6mr_ioctl(struct sock *sk, int cmd
 		}
 		read_unlock(&mrt_lock);
 		return -EADDRNOTAVAIL;
+	case SIOCSETSGCNT_IN6:
+		if (copy_from_user(&sr, arg, sizeof(sr)))
+			return -EFAULT;
+
+		rtnl_lock();
+		c = ip6mr_cache_find(mrt, &sr.src.sin6_addr, &sr.grp.sin6_addr);
+		if (!c) {
+			rtnl_unlock();
+			return -EADDRNOTAVAIL;
+		}
+		write_lock_bh(&mrt_lock);
+		c->_c.mfc_un.res.dp_stat.mfcs_packets = sr.pktcnt;
+		c->_c.mfc_un.res.dp_stat.mfcs_bytes = sr.bytecnt;
+		c->_c.mfc_un.res.dp_stat.mfcs_wrong_if = sr.wrong_if;
+		write_unlock_bh(&mrt_lock);
+		rtnl_unlock();
+		return 0;
 	case SIOCGETSGCNT_IN6:
 		if (copy_from_user(&sr, arg, sizeof(sr)))
 			return -EFAULT;
@@ -1898,9 +1915,12 @@ int ip6mr_ioctl(struct sock *sk, int cmd
 		rcu_read_lock();
 		c = ip6mr_cache_find(mrt, &sr.src.sin6_addr, &sr.grp.sin6_addr);
 		if (c) {
-			sr.pktcnt = c->_c.mfc_un.res.pkt;
-			sr.bytecnt = c->_c.mfc_un.res.bytes;
-			sr.wrong_if = c->_c.mfc_un.res.wrong_if;
+			sr.pktcnt = c->_c.mfc_un.res.pkt +
+					c->_c.mfc_un.res.dp_stat.mfcs_packets;
+			sr.bytecnt = c->_c.mfc_un.res.bytes +
+					c->_c.mfc_un.res.dp_stat.mfcs_bytes;
+			sr.wrong_if = c->_c.mfc_un.res.wrong_if +
+					c->_c.mfc_un.res.dp_stat.mfcs_wrong_if;
 			rcu_read_unlock();
 
 			if (copy_to_user(arg, &sr, sizeof(sr)))
@@ -1966,6 +1986,24 @@ int ip6mr_compat_ioctl(struct sock *sk,
 		}
 		read_unlock(&mrt_lock);
 		return -EADDRNOTAVAIL;
+	case SIOCSETSGCNT_IN6:
+		if (copy_from_user(&sr, arg, sizeof(sr)))
+			return -EFAULT;
+
+		rtnl_lock();
+		c = ip6mr_cache_find(mrt, &sr.src.sin6_addr, &sr.grp.sin6_addr);
+		if (!c) {
+			rtnl_unlock();
+			return -EADDRNOTAVAIL;
+		}
+
+		write_lock_bh(&mrt_lock);
+		c->_c.mfc_un.res.dp_stat.mfcs_packets = sr.pktcnt;
+		c->_c.mfc_un.res.dp_stat.mfcs_bytes = sr.bytecnt;
+		c->_c.mfc_un.res.dp_stat.mfcs_wrong_if = sr.wrong_if;
+		write_unlock_bh(&mrt_lock);
+		rtnl_unlock();
+		return 0;
 	case SIOCGETSGCNT_IN6:
 		if (copy_from_user(&sr, arg, sizeof(sr)))
 			return -EFAULT;
@@ -1973,9 +2011,12 @@ int ip6mr_compat_ioctl(struct sock *sk,
 		rcu_read_lock();
 		c = ip6mr_cache_find(mrt, &sr.src.sin6_addr, &sr.grp.sin6_addr);
 		if (c) {
-			sr.pktcnt = c->_c.mfc_un.res.pkt;
-			sr.bytecnt = c->_c.mfc_un.res.bytes;
-			sr.wrong_if = c->_c.mfc_un.res.wrong_if;
+			sr.pktcnt = c->_c.mfc_un.res.pkt +
+					c->_c.mfc_un.res.dp_stat.mfcs_packets;
+			sr.bytecnt = c->_c.mfc_un.res.bytes +
+					c->_c.mfc_un.res.dp_stat.mfcs_bytes;
+			sr.wrong_if = c->_c.mfc_un.res.wrong_if +
+					c->_c.mfc_un.res.dp_stat.mfcs_wrong_if;
 			rcu_read_unlock();
 
 			if (copy_to_user(arg, &sr, sizeof(sr)))
