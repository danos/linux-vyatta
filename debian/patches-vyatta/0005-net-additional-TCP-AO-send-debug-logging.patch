From 86dc99470924b4ba6e82af44c563a82dab2ddf8b Mon Sep 17 00:00:00 2001
From: Duncan Eastoe <deastoe@vyatta.att-mail.com>
Date: Tue, 27 Aug 2019 13:40:02 +0100
Subject: [PATCH 5/6] net: additional TCP-AO send debug logging

The rate limited logs print the first byte of the traffic key used
to authenticate transmitted segments. This is useful data to have
when debugging MAC mismatch failures, since the send traffic key
should match the receive traffic key on the remote end.

They are disabled by default and can be enabled by the new
tcp_auth_debug sysctl.

Signed-off-by: Duncan Eastoe <deastoe@vyatta.att-mail.com>
---
 include/net/netns/ipv4.h   |  1 +
 include/net/tcp.h          |  2 ++
 net/ipv4/sysctl_net_ipv4.c |  7 +++++++
 net/ipv4/tcp_auth.c        |  5 +++++
 net/ipv4/tcp_ipv4.c        |  2 ++
 net/ipv4/tcp_output.c      | 13 +++++++++++++
 6 files changed, 30 insertions(+)

--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@ -184,6 +184,7 @@ struct netns_ipv4 {
 	atomic_t tfo_active_disable_times;
 	unsigned long tfo_active_disable_stamp;
 	int sysctl_tcp_reflect_tos;
+	int sysctl_tcp_auth_debug;
 
 	int sysctl_udp_wmem_min;
 	int sysctl_udp_rmem_min;
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -1770,6 +1770,8 @@ int tcp_auth_debug_sockaddrs(const struc
 #define tcp_auth_inbound_log_init(s, o) \
 	struct tcp_auth_debug_ctx __auth_debug_ctx = { .skb = (s), .ops = (o) }
 
+#define tcp_auth_debug_is_on(s) (sock_net(s)->ipv4.sysctl_tcp_auth_debug)
+
 int tcp_parse_auth_option(const struct tcphdr *th,
 			  const struct tcp_auth_opt **opt);
 
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@ -1339,6 +1339,13 @@ static struct ctl_table ipv4_net_table[]
 		.extra2         = SYSCTL_ONE,
 	},
 	{
+		.procname	= "tcp_auth_debug",
+		.data		= &init_net.ipv4.sysctl_tcp_auth_debug,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec
+	},
+	{
 		.procname	= "udp_rmem_min",
 		.data		= &init_net.ipv4.sysctl_udp_rmem_min,
 		.maxlen		= sizeof(init_net.ipv4.sysctl_udp_rmem_min),
--- a/net/ipv4/tcp_auth.c
+++ b/net/ipv4/tcp_auth.c
@@ -1583,6 +1583,11 @@ int tcp_auth_send_fill_opt(const struct
 		}
 	}
 
+	tcp_auth_log_ratelimit_cond(KERN_DEBUG, tcp_auth_debug_is_on(sk),
+				    th->dest, th->source,
+				    "Computing output MAC using key with send ID %u (0x%02X...)",
+				    curr_send_key, tkey.key[0]);
+
 	opt->kind = TCPOPT_AUTH;
 	opt->length = TCPOLEN_AUTH(auth->current_key->alg);
 	opt->key_id = curr_send_key;
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -3195,6 +3195,8 @@ static int __net_init tcp_sk_init(struct
 	net->ipv4.sysctl_tcp_fastopen_blackhole_timeout = 0;
 	atomic_set(&net->ipv4.tfo_active_disable_times, 0);
 
+	net->ipv4.sysctl_tcp_auth_debug = 0;
+
 	/* Reno is always built in */
 	if (!net_eq(net, &init_net) &&
 	    bpf_try_module_get(init_net.ipv4.tcp_congestion_control,
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -1462,6 +1462,12 @@ static int __tcp_transmit_skb(struct soc
 			}
 		}
 
+		tcp_auth_log_ratelimit_cond(KERN_DEBUG,
+					    tcp_auth_debug_is_on(sk),
+					    th->source, th->dest,
+					    "Computing output MAC using key with send ID %u (0x%02X...)",
+					    curr_send_key, tkey.key[0]);
+
 		sne = tcp_auth_get_sne(&params->send_sne, th->seq);
 		err = tcp_auth_hash_skb(&tp->af_specific->auth_ops,
 					opts.hash_location, &tkey,
@@ -3758,6 +3764,13 @@ struct sk_buff *tcp_make_synack(const st
 			goto fail;
 		}
 
+		tcp_auth_log_ratelimit_cond(KERN_DEBUG,
+					    tcp_auth_debug_is_on(sk),
+					    th->source, th->dest,
+					    "Computing output SYN/ACK MAC using key with send ID %u (0x%02X...)",
+					    current_key->id[TCP_AUTH_SEND],
+					    tkey.key[0]);
+
 		sne = tcp_auth_get_sne(&req_params->send_sne, th->seq);
 		ret = tcp_auth_hash_skb(&tp->af_specific->auth_ops,
 					opts.hash_location, &tkey,
