From 7348fd97692fdf5cc45c052665b1b9b2099a2aeb Mon Sep 17 00:00:00 2001
From: Stephen Hemminger <stephen@networkplumber.org>
Date: Tue, 9 Jul 2013 15:35:31 -0700
Subject: [PATCH 003/139] linkfilter: patch

Vyatta addition to allow ignoring carrier transistions.

Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>

---
 Documentation/networking/ip-sysctl.txt |   13 +++++++++++++
 include/linux/inetdevice.h             |    1 +
 include/linux/ipv6.h                   |    1 +
 include/uapi/linux/ip.h                |    1 +
 include/uapi/linux/ipv6.h              |    1 +
 net/ipv4/devinet.c                     |    1 +
 net/ipv4/route.c                       |    7 +++++++
 net/ipv6/addrconf.c                    |    8 ++++++++
 net/ipv6/route.c                       |   11 +++++++++++
 9 files changed, 44 insertions(+)

--- a/include/linux/inetdevice.h
+++ b/include/linux/inetdevice.h
@@ -133,6 +133,7 @@ static inline void ipv4_devconf_setall(s
 #define IN_DEV_ARP_ANNOUNCE(in_dev)	IN_DEV_MAXCONF((in_dev), ARP_ANNOUNCE)
 #define IN_DEV_ARP_IGNORE(in_dev)	IN_DEV_MAXCONF((in_dev), ARP_IGNORE)
 #define IN_DEV_ARP_NOTIFY(in_dev)	IN_DEV_MAXCONF((in_dev), ARP_NOTIFY)
+#define IN_DEV_LINKFILTER(in_dev)	IN_DEV_MAXCONF((in_dev), LINKFILTER)
 
 struct in_ifaddr {
 	struct hlist_node	hash;
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@ -75,6 +75,7 @@ struct ipv6_devconf {
 	__s32		disable_policy;
 	__s32           ndisc_tclass;
 	__s32		rpl_seg_enabled;
+	__s32		link_filter;
 
 	struct ctl_table_header *sysctl_header;
 };
--- a/include/uapi/linux/ip.h
+++ b/include/uapi/linux/ip.h
@@ -169,6 +169,7 @@ enum
 	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST,
 	IPV4_DEVCONF_DROP_GRATUITOUS_ARP,
 	IPV4_DEVCONF_BC_FORWARDING,
+	IPV4_DEVCONF_LINKFILTER,
 	__IPV4_DEVCONF_MAX
 };
 
--- a/include/uapi/linux/ipv6.h
+++ b/include/uapi/linux/ipv6.h
@@ -189,6 +189,7 @@ enum {
 	DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN,
 	DEVCONF_NDISC_TCLASS,
 	DEVCONF_RPL_SEG_ENABLED,
+	DEVCONF_LINK_FILTER = DEVCONF_RPL_SEG_ENABLED + 10,
 	DEVCONF_MAX
 };
 
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -2547,6 +2547,7 @@ static struct devinet_sysctl_table {
 					      "route_localnet"),
 		DEVINET_SYSCTL_FLUSHING_ENTRY(DROP_UNICAST_IN_L2_MULTICAST,
 					      "drop_unicast_in_l2_multicast"),
+		DEVINET_SYSCTL_RW_ENTRY(LINKFILTER, "link_filter"),
 	},
 };
 
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -2200,6 +2200,15 @@ static int ip_route_input_slow(struct sk
 	}
 
 	if (res->type == RTN_LOCAL) {
+		struct fib_nh_common *nhc = fib_info_nhc(res->fi, 0);
+
+		int linkf = IN_DEV_LINKFILTER(in_dev);
+
+		if (linkf && !netif_running(nhc->nhc_dev))
+			goto no_route;
+		if (linkf > 1 && !netif_carrier_ok(nhc->nhc_dev))
+			goto no_route;
+
 		err = fib_validate_source(skb, saddr, daddr, tos,
 					  0, dev, in_dev, &itag);
 		if (err < 0)
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -5517,6 +5517,7 @@ static inline void ipv6_store_devconf(st
 	array[DEVCONF_DISABLE_POLICY] = cnf->disable_policy;
 	array[DEVCONF_NDISC_TCLASS] = cnf->ndisc_tclass;
 	array[DEVCONF_RPL_SEG_ENABLED] = cnf->rpl_seg_enabled;
+	array[DEVCONF_LINK_FILTER] = cnf->link_filter;
 }
 
 static inline size_t inet6_ifla6_size(void)
@@ -6523,6 +6524,13 @@ static const struct ctl_table addrconf_s
 		.proc_handler	= addrconf_sysctl_forward,
 	},
 	{
+		.procname       = "link_filter",
+		.data           = &ipv6_devconf.link_filter,
+		.maxlen         = sizeof(int),
+		.mode           = 0644,
+		.proc_handler   = proc_dointvec
+	},
+	{
 		.procname	= "hop_limit",
 		.data		= &ipv6_devconf.hop_limit,
 		.maxlen		= sizeof(int),
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -700,6 +700,15 @@ static enum rt6_nud_state rt6_check_neig
 	return ret;
 }
 
+static inline int rt6_link_filter(struct fib6_nh *nh)
+{
+	struct net_device *dev = nh->fib_nh_dev;
+	int linkf = __in6_dev_get(dev)->cnf.link_filter;
+
+	return (linkf && !netif_running(dev))
+		|| (linkf > 1 && !netif_carrier_ok(dev));
+}
+
 static int rt6_score_route(const struct fib6_nh *nh, u32 fib6_flags, int oif,
 			   int strict)
 {
@@ -710,6 +719,8 @@ static int rt6_score_route(const struct
 
 	if (!m && (strict & RT6_LOOKUP_F_IFACE))
 		return RT6_NUD_FAIL_HARD;
+	if (rt6_link_filter(nh))
+		return RT6_NUD_FAIL_HARD;
 #ifdef CONFIG_IPV6_ROUTER_PREF
 	m |= IPV6_DECODE_PREF(IPV6_EXTRACT_PREF(fib6_flags)) << 2;
 #endif
--- a/Documentation/networking/ip-sysctl.rst
+++ b/Documentation/networking/ip-sysctl.rst
@@ -1424,6 +1424,19 @@ rp_filter - INTEGER
 	Default value is 0. Note that some distributions enable it
 	in startup scripts.
 
+link_filter - INTEGER
+	- 0 - Allow packets to be received for the address on this interface
+	  even if interface is disabled or no carrier.
+
+	- 1 - Ignore packets received if interface associated with the incoming
+	  address is down.
+
+	- 2 - Ignore packets received if interface associated with the incoming
+	  address is down or has no carrier.
+
+	Default value is 0. Note that some distributions enable it
+	in startup scripts.
+
 arp_filter - BOOLEAN
 	- 1 - Allows you to have multiple network interfaces on the same
 	  subnet, and have the ARPs for each interface be answered
