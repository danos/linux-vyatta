From 8991a257d5ec024cae7ccc8d3639845b24b288ef Mon Sep 17 00:00:00 2001
From: "Charles (Chas) Williams" <ciwillia@vyatta.att-mail.com>
Date: Wed, 20 May 2020 10:00:50 -0400
Subject: [PATCH] Revert "ipmi_ssif: avoid registering duplicate ssif
 interface"

DMI based interfaces are registered with a NULL adapter name.  When
the check for duplicate names is done, strcmp fails because it can't
dereference the NULL pointer. It's not clear if the name based matching
should be done in this case.  Regardless, revert to previous behavior
to prevent additional breakage.

This reverts commit c4436c9149c5d2bc0c49ab57ec85c75ea1c4d61c.
---
 drivers/char/ipmi/ipmi_ssif.c | 78 +------------------------------------------
 1 file changed, 1 insertion(+), 77 deletions(-)

diff --git a/drivers/char/ipmi/ipmi_ssif.c b/drivers/char/ipmi/ipmi_ssif.c
index 2704470e021d..3e9ab8e996c2 100644
--- a/drivers/char/ipmi/ipmi_ssif.c
+++ b/drivers/char/ipmi/ipmi_ssif.c
@@ -1433,10 +1433,6 @@ static struct ssif_addr_info *ssif_info_find(unsigned short addr,
 restart:
 	list_for_each_entry(info, &ssif_infos, link) {
 		if (info->binfo.addr == addr) {
-			if (info->addr_src == SI_SMBIOS)
-				info->adapter_name = kstrdup(adapter_name,
-							     GFP_KERNEL);
-
 			if (info->adapter_name || adapter_name) {
 				if (!info->adapter_name != !adapter_name) {
 					/* One is NULL and one is not */
@@ -1612,60 +1608,6 @@ static void test_multipart_messages(struct i2c_client *client,
 #define GLOBAL_ENABLES_MASK (IPMI_BMC_EVT_MSG_BUFF | IPMI_BMC_RCV_MSG_INTR | \
 			     IPMI_BMC_EVT_MSG_INTR)
 
-static void ssif_remove_dup(struct i2c_client *client)
-{
-	struct ssif_info *ssif_info = i2c_get_clientdata(client);
-
-	ipmi_unregister_smi(ssif_info->intf);
-	kfree(ssif_info);
-}
-
-static int ssif_add_infos(struct i2c_client *client)
-{
-	struct ssif_addr_info *info;
-
-	info = kzalloc(sizeof(*info), GFP_KERNEL);
-	if (!info)
-		return -ENOMEM;
-	info->addr_src = SI_ACPI;
-	info->client = client;
-	info->adapter_name = kstrdup(client->adapter->name, GFP_KERNEL);
-	info->binfo.addr = client->addr;
-	list_add_tail(&info->link, &ssif_infos);
-	return 0;
-}
-
-/*
- * Prefer ACPI over SMBIOS, if both are available.
- * So if we get an ACPI interface and have already registered a SMBIOS
- * interface at the same address, remove the SMBIOS and add the ACPI one.
- */
-static int ssif_check_and_remove(struct i2c_client *client,
-			      struct ssif_info *ssif_info)
-{
-	struct ssif_addr_info *info;
-
-	list_for_each_entry(info, &ssif_infos, link) {
-		if (!info->client)
-			return 0;
-		if (!strcmp(info->adapter_name, client->adapter->name) &&
-		    info->binfo.addr == client->addr) {
-			if (info->addr_src == SI_ACPI)
-				return -EEXIST;
-
-			if (ssif_info->addr_source == SI_ACPI &&
-			    info->addr_src == SI_SMBIOS) {
-				dev_info(&client->dev,
-					 "Removing %s-specified SSIF interface in favor of ACPI\n",
-					 ipmi_addr_src_to_str(info->addr_src));
-				ssif_remove_dup(info->client);
-				return 0;
-			}
-		}
-	}
-	return 0;
-}
-
 static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
 	unsigned char     msg[3];
@@ -1677,17 +1619,13 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	u8		  slave_addr = 0;
 	struct ssif_addr_info *addr_info = NULL;
 
-	mutex_lock(&ssif_infos_mutex);
 	resp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);
-	if (!resp) {
-		mutex_unlock(&ssif_infos_mutex);
+	if (!resp)
 		return -ENOMEM;
-	}
 
 	ssif_info = kzalloc(sizeof(*ssif_info), GFP_KERNEL);
 	if (!ssif_info) {
 		kfree(resp);
-		mutex_unlock(&ssif_infos_mutex);
 		return -ENOMEM;
 	}
 
@@ -1706,19 +1644,6 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		}
 	}
 
-	rv = ssif_check_and_remove(client, ssif_info);
-	/* If rv is 0 and addr source is not SI_ACPI, continue probing */
-	if (!rv && ssif_info->addr_source == SI_ACPI) {
-		rv = ssif_add_infos(client);
-		if (rv) {
-			dev_err(&client->dev, "Out of memory!, exiting ..\n");
-			goto out;
-		}
-	} else if (rv) {
-		dev_err(&client->dev, "Not probing, Interface already present\n");
-		goto out;
-	}
-
 	slave_addr = find_slave_address(client, slave_addr);
 
 	dev_info(&client->dev,
@@ -1931,7 +1856,6 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		kfree(ssif_info);
 	}
 	kfree(resp);
-	mutex_unlock(&ssif_infos_mutex);
 	return rv;
 
 out_remove_attr:
-- 
2.11.0

