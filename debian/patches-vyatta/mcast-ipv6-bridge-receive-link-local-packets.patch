mcast: ensure L-L IPv6 packets are accepted by bridge

At present only all-nodes IPv6 multicast packets are accepted by
a bridge interface that is not in multicast router mode. Since
other protocols can be running in the absense of multicast
forwarding e.g. OSPFv3 IPv6 ND. Change the test to allow
all of the FFx2::/16 range to be accepted when not in multicast
router mode. This aligns the code with IPv4 link-local reception
and RFC4291

Signed-off-by: Patrick Ruddy <pruddy@vyatta.att-mail.com>
--- linux-vyatta.orig/net/bridge/br_multicast.c
+++ linux-vyatta/net/bridge/br_multicast.c
@@ -1856,7 +1856,7 @@ static int br_multicast_ipv6_rcv(struct
 	err = ipv6_mc_check_mld(skb, &skb_trimmed);
 
 	if (err == -ENOMSG) {
-		if (!ipv6_addr_is_ll_all_nodes(&ipv6_hdr(skb)->daddr))
+		if (!ipv6_addr_is_ll_mcast(&ipv6_hdr(skb)->daddr))
 			BR_INPUT_SKB_CB(skb)->mrouters_only = 1;
 		return 0;
 	} else if (err < 0) {
--- linux-vyatta.orig/include/net/addrconf.h
+++ linux-vyatta/include/net/addrconf.h
@@ -438,6 +438,21 @@ static inline void addrconf_addr_solict_
 		      htonl(0xFF000000) | addr->s6_addr32[3]);
 }
 
+/*
+ *      link local multicast address range ffx2::/16 rfc4291
+ */
+static inline bool ipv6_addr_is_ll_mcast(const struct in6_addr *addr)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
+	__be64 *p = (__be64 *)addr;
+	return ((p[0] & cpu_to_be64(0xff0f000000000000UL))
+		^ cpu_to_be64(0xff02000000000000UL)) == 0UL;
+#else
+	return ((addr->s6_addr32[0] & htonl(0xff0f0000)) ^
+		htonl(0xff020000)) == 0;
+#endif
+}
+
 static inline bool ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
 {
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
