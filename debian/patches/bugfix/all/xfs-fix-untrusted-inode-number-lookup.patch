commit 4536f2ad8b330453d7ebec0746c4374eadd649b1
Author: Dave Chinner <dchinner@redhat.com>
Date:   Tue Aug 24 11:42:30 2010 +1000

    xfs: fix untrusted inode number lookup
    
    Commit 7124fe0a5b619d65b739477b3b55a20bf805b06d ("xfs: validate untrusted inode
    numbers during lookup") changes the inode lookup code to do btree lookups for
    untrusted inode numbers. This change made an invalid assumption about the
    alignment of inodes and hence incorrectly calculated the first inode in the
    cluster. As a result, some inode numbers were being incorrectly considered
    invalid when they were actually valid.
    
    The issue was not picked up by the xfstests suite because it always runs fsr
    and dump (the two utilities that utilise the bulkstat interface) on cache hot
    inodes and hence the lookup code in the cold cache path was not sufficiently
    exercised to uncover this intermittent problem.
    
    Fix the issue by relaxing the btree lookup criteria and then checking if the
    record returned contains the inode number we are lookup for. If it we get an
    incorrect record, then the inode number is invalid.
    
    Cc: <stable@kernel.org>
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    [dannf: adjusted to apply to Debian's 2.6.32]

diff -urpN a/fs/xfs/xfs_ialloc.c b/fs/xfs/xfs_ialloc.c
--- a/fs/xfs/xfs_ialloc.c	2011-01-06 23:33:35.978687390 -0700
+++ b/fs/xfs/xfs_ialloc.c	2011-01-06 23:34:37.414682825 -0700
@@ -1220,7 +1220,6 @@ xfs_imap_lookup(
 	struct xfs_inobt_rec_incore rec;
 	struct xfs_btree_cur	*cur;
 	struct xfs_buf		*agbp;
-	xfs_agino_t		startino;
 	int			error;
 	int			i;
 
@@ -1236,13 +1235,13 @@ xfs_imap_lookup(
 	}
 
 	/*
-	 * derive and lookup the exact inode record for the given agino. If the
-	 * record cannot be found, then it's an invalid inode number and we
-	 * should abort.
+	 * Lookup the inode record for the given agino. If the record cannot be
+	 * found, then it's an invalid inode number and we should abort. Once
+	 * we have a record, we need to ensure it contains the inode number
+	 * we are looking up.
 	 */
 	cur = xfs_inobt_init_cursor(mp, tp, agbp, agno);
-	startino = agino & ~(XFS_IALLOC_INODES(mp) - 1);
-	error = xfs_inobt_lookup(cur, startino, XFS_LOOKUP_EQ, &i);
+	error = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_LE, &i);
 	if (!error) {
 		if (i)
 			error = xfs_inobt_get_rec(cur, &rec, &i);
@@ -1255,6 +1254,11 @@ xfs_imap_lookup(
 	if (error)
 		return error;
 
+	/* check that the returned record contains the required inode */
+	if (rec.ir_startino > agino ||
+	    rec.ir_startino + XFS_IALLOC_INODES(mp) <= agino)
+		return EINVAL;
+
 	/* for untrusted inodes check it is allocated first */
 	if ((flags & XFS_IGET_UNTRUSTED) &&
 	    (rec.ir_free & XFS_INOBT_MASK(agino - rec.ir_startino)))
